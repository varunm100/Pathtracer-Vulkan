#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable

#include "raycommon.glsl"
#include "random.glsl"

layout(binding = 0, set = 0) uniform CameraData {
  mat4 view;
  mat4 proj;
  mat4 viewInverse;
  mat4 projInverse;
} cam;
layout(binding = 1, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 2, set = 0, rgba32f) uniform image2D image;

layout(location = 0) rayPayloadEXT hitPayload prd;

layout( push_constant ) uniform RtConfig {
  uint sample_count;
  uint max_bounce;
  float gamma;
  float exposure;
} PushConstant;

void main() {
  uint num_samples = PushConstant.sample_count;
  uint num_bounces = PushConstant.max_bounce;
  float gamma = PushConstant.gamma;
  float exposure = PushConstant.exposure;

  prd.seed = InitRandomSeed(InitRandomSeed(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), num_samples);
  uint pixelRandomSeed = prd.seed;
  vec3 pixel_color = vec3(0);

  uint rayFlags = gl_RayFlagsOpaqueEXT;
  float tMin = 0.001f;
  float tMax = 10000.0f;

  for(uint s = 0; s < num_samples; ++s) {
    const vec2 pixel = vec2(gl_LaunchIDEXT.x + RandomFloat(pixelRandomSeed), gl_LaunchIDEXT.y + RandomFloat(pixelRandomSeed));
    const vec2 uv = (pixel / gl_LaunchSizeEXT.xy) * 2.0 - 1.0;
    
    vec4 origin = cam.viewInverse * vec4(0, 0, 0, 1);
    vec4 target = cam.projInverse * vec4(uv.x, uv.y, 1, 1);
    vec4 direction = cam.viewInverse * vec4(normalize(target.xyz), 0);
    vec3 ray_color = vec3(1);

    for(uint sc = 0; sc <= num_bounces; ++sc) {
      traceRayEXT(  topLevelAS,   // acceleration structure
                    rayFlags,     // rayFlags
                    0xFF,         // cullMask
                    0,            // stbRecordOffset
                    0,            // stbRecordStride
                    0,            // missIndex
                    origin.xyz,   // ray origin
                    tMin,         // ray min range
                    direction.xyz,// ray direction
                    tMax,         // ray max range
                    0);           // payload (location = 0);
       
      const vec3 hit_color = prd.color_dist.rgb;
      const float t = prd.color_dist.w;
      const bool is_scattered = prd.scatter_dir.w > 0;

      ray_color *= hit_color;
      if(t < 0 || !is_scattered) break;

      origin = origin + t*direction;
      direction = vec4(prd.scatter_dir.xyz, 0);
    }
    pixel_color += ray_color;
  }
  const vec3 accum_color = pixel_color;
  pixel_color = accum_color/num_samples;
  pixel_color *= exposure;
  pixel_color = ACESFilm(pixel_color);
  pixel_color = linear_to_srgb(pixel_color);
  
  imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(pixel_color.z, pixel_color.y, pixel_color.x, 1.0));
}
